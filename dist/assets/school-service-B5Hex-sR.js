var ie=Object.defineProperty;var ce=(c,e,s)=>e in c?ie(c,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):c[e]=s;var g=(c,e,s)=>ce(c,typeof e!="symbol"?e+"":e,s);import{I as u,O as re,J as y,P as te,T as S,Q as G,R as ee}from"./index-C2OCLzvt.js";import{A as Y,u as H,D as J,S as de}from"./school-repository-Cn0NCeLd.js";import{L as w,S as se,y as ae}from"./model-DjcFpkp9.js";const q=class q extends Y{constructor(){super(e=>H(J.STUDENTS,e))}static get instance(){return this._instance||(this._instance=new q),this._instance}};g(q,"_instance",null);let O=q;const C=class C extends Y{constructor(){super(e=>H(J.WEEKLY_LESSONS,e))}static get instance(){return this._instance||(this._instance=new C),this._instance}};g(C,"_instance",null);let B=C;const P=class P extends Y{constructor(){super(e=>H(J.DAILY_LESSONS,e))}static get instance(){return this._instance||(this._instance=new P),this._instance}};g(P,"_instance",null);let d=P;var I=[];for(var K=0;K<256;++K)I.push((K+256).toString(16).slice(1));function le(c,e=0){return(I[c[e+0]]+I[c[e+1]]+I[c[e+2]]+I[c[e+3]]+"-"+I[c[e+4]]+I[c[e+5]]+"-"+I[c[e+6]]+I[c[e+7]]+"-"+I[c[e+8]]+I[c[e+9]]+"-"+I[c[e+10]]+I[c[e+11]]+I[c[e+12]]+I[c[e+13]]+I[c[e+14]]+I[c[e+15]]).toLowerCase()}var A,ye=new Uint8Array(16);function ue(){if(!A&&(A=typeof crypto<"u"&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto),!A))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return A(ye)}var fe=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto);const ne={randomUUID:fe};function Q(c,e,s){if(ne.randomUUID&&!e&&!c)return ne.randomUUID();c=c||{};var n=c.random||(c.rng||ue)();return n[6]=n[6]&15|64,n[8]=n[8]&63|128,le(n)}const M=class M extends Y{constructor(){super(e=>H(J.RECOVERY_LESSONS,e))}static get instance(){return this._instance||(this._instance=new M),this._instance}};g(M,"_instance",null);let R=M;const k=class k{static get instance(){return this._instance||(this._instance=new k),this._instance}async getStudentsOfSchool(e){const s=u(y("schoolId"),"==",e);return O.instance.getAll(s)}observeStudentsOfSchool(e){const s=u(y("schoolId"),"==",e);return O.instance.observeAll(s)}async getStudentsOfSchoolWithIds(e,s){if(s.length==0)return[];const n=u(y("schoolId"),"==",e),t=u(re(),"in",s);return O.instance.getAll(n,t)}};g(k,"_instance",null);let b=k;var ve=(c=>(c[c.SET_PRESENT=0]="SET_PRESENT",c[c.SET_ABSENT=1]="SET_ABSENT",c[c.CANCEL=2]="CANCEL",c[c.RESET=3]="RESET",c))(ve||{});const _=class _{static get instance(){return this._instance||(this._instance=new _),this._instance}async computeDailyLessons(e){const s=Array.from(new Set(e.recoveries.flatMap(f=>{var h;return[f.originalLesson.dailyLessonId,(h=f.recoveryLesson)==null?void 0:h.dailyLessonId]}).filter(Boolean))),t=(await Promise.all(s.map(f=>d.instance.get(f)))).filter(Boolean),a=await b.instance.getStudentsOfSchool(e.schoolId),o=[],i=[],r=[],l=(f,h,m,p,L)=>{m.push({...f,...h,...p,recoveryStatus:L})};return e.recoveries.forEach(f=>{const{originalLesson:h,recoveryLesson:m,status:p}=f,L=t.find(v=>v.id===h.dailyLessonId),T=m?t.find(v=>v.id===m.dailyLessonId):void 0;if(!L){console.warn("Unable to load original daily lesson of a recovery...");return}const D={originalDailyLesson:L,recoveryDailyLesson:T};L.lessons.forEach(v=>{if(v.lessonId!==h.lessonId)return;const N=a.find(oe=>oe.id===v.studentId);N&&(T?p!=null?l(v,N,r,D,p):l(v,N,i,D):l(v,N,o,D))})}),{recoveryMap:[{type:"unset",recoveries:o},{type:"pending",recoveries:i},{type:"done",recoveries:r}],schoolId:e.schoolId}}async getOrCreate(e){const s=await R.instance.getDoc(e);if(s.exists())return s.data();const n={recoveries:[],schoolId:e};return await R.instance.save(n,e),n}getRecoveryType(e){return!e.status&&!e.recoveryLesson?0:!e.status&&e.recoveryLesson?1:2}addRecoveryByType(e,s,n,t){let a=e.recoveries.findIndex(i=>i.originalLesson.dailyLessonId==s.dailyLessonId&&i.originalLesson.lessonId==s.lessonId);a==-1&&(e.recoveries.push({originalLesson:s}),a=e.recoveries.length-1);const o=e.recoveries[a];n==0?o.originalLesson=t:n==1?o.recoveryLesson=t:o.status=t}removeRecoveryByType(e,s,n){const t=e.recoveries.findIndex(a=>a.originalLesson.dailyLessonId==s.dailyLessonId&&a.originalLesson.lessonId==s.lessonId);if(t!=-1){if(n==0)return e.recoveries.splice(t,1),!0;if(n==1){if(e.recoveries[t].recoveryLesson)return delete e.recoveries[t].recoveryLesson,!0}else if(e.recoveries[t].status)return delete e.recoveries[t].status,!0}return!1}async updateRecovery(e,s,...n){var a;const t=await _.instance.getOrCreate(s);for await(const o of n){const i=((a=o.recovery)==null?void 0:a.ref)=="original",r=i?{dailyLessonId:o.recovery.lessonRef.dailyLessonId,lessonId:o.recovery.lessonRef.lessonId}:{dailyLessonId:o.dailyLessonId,lessonId:o.lessonId};if(e==0)if(!i)this.removeRecoveryByType(t,r,0);else{const l=w.PRESENT;this.addRecoveryByType(t,r,2,l)}else if(e==1)if(i){const l={...r};this.removeRecoveryByType(t,r,1),this.addRecoveryByType(t,r,0,l);const f=r.lessonId,h=await d.instance.get(r.dailyLessonId);await E.instance.moveRecoveryRefToUndoneList(h,f)}else{const l={...r};this.addRecoveryByType(t,r,0,l)}else if(e==2)if(!i)this.removeRecoveryByType(t,r,0);else{const l=w.CANCELLED;this.addRecoveryByType(t,r,2,l)}else if(e==3){if(!i)this.removeRecoveryByType(t,r,0);else if(!this.removeRecoveryByType(t,r,2)){const f={dailyLessonId:o.dailyLessonId,lessonId:o.lessonId};this.addRecoveryByType(t,r,1,f);const h=r.lessonId,m=o.lessonId,p={lessonRef:{...r},ref:"original"},L={lessonRef:{...f},ref:"recovery"},T=await d.instance.get(r.dailyLessonId),D=await d.instance.get(o.dailyLessonId);await E.instance.addRecoveryRef(T,h,L),await E.instance.addRecoveryRef(D,m,p)}}}R.instance.save(t,s)}async scheduleRecovery(e,s){const n=await _.instance.getOrCreate(e.schoolId),t=await E.instance.createRecoveryLesson(s),a=await d.instance.getDoc(e.originalDailyLesson.id);if(a.exists()){const r=a.data(),l=r.lessons.find(f=>f.lessonId==e.lessonId);l&&(l.recovery={ref:"recovery",lessonRef:{dailyLessonId:t.dailyLessonId,lessonId:t.lessonId}},await d.instance.save(r,r.id))}else console.warn("");const o={dailyLessonId:e.originalDailyLesson.id,lessonId:e.lessonId},i={dailyLessonId:t.dailyLessonId,lessonId:t.lessonId};this.addRecoveryByType(n,o,1,i),R.instance.save(n,e.schoolId)}async cancelRecovery(e,s){var h,m,p,L,T,D;if(!e.recoveryDailyLesson)return;const n=await _.instance.getOrCreate(e.schoolId);let t,a;const o=[];((h=e.recovery)==null?void 0:h.ref)=="recovery"?(t=e.recovery.lessonRef,a=(p=(m=e.recoveryDailyLesson.lessons.find(v=>v.lessonId==(t==null?void 0:t.lessonId)))==null?void 0:m.recovery)==null?void 0:p.lessonRef):((L=e.recovery)==null?void 0:L.ref)=="original"&&(a=e.recovery.lessonRef,t=(D=(T=e.originalDailyLesson.lessons.find(v=>v.lessonId==(a==null?void 0:a.lessonId)))==null?void 0:T.recovery)==null?void 0:D.lessonRef);const i=await d.instance.get(e.recoveryDailyLesson.id),r=i==null?void 0:i.lessons.findIndex(v=>v.lessonId==(t==null?void 0:t.lessonId));i&&r!=null&&r!=-1&&(i.lessons.splice(r,1),i.lessons.length==0?await d.instance.delete(i.id):await d.instance.save(i,i.id));const l=await d.instance.get(e.originalDailyLesson.id),f=l==null?void 0:l.lessons.findIndex(v=>v.lessonId==(a==null?void 0:a.lessonId));l&&f!=null&&f!=-1&&(delete l.lessons[f].recovery,await d.instance.save(l,l.id)),a&&(o.push(2,1),s&&o.push(0),o.forEach(v=>this.removeRecoveryByType(n,a,v)),await R.instance.save(n,e.schoolId))}};g(_,"_instance",null);let z=_;const W=class W{static get instance(){return this._instance||(this._instance=new W),this._instance}async getStudentLesson(e,s){s??(s=e.lessons.map(t=>t.studentId));const n=await b.instance.getStudentsOfSchoolWithIds(e.schoolId,s);return e.lessons.map(t=>{const a=n.find(o=>o.id==t.studentId);return{...t,...a}})}};g(W,"_instance",null);let U=W;const F=class F{static get instance(){return this._instance||(this._instance=new F),this._instance}async computeSalary(e,s,n){const t=await E.instance.getDailyLessonOfSchoolBetweenDate(e.id,s,n);return this.computeSalaryOfDailyLessons(t)}async computeSalaryOfDailyLessons(e){const s=[];return e.forEach(n=>{const t=n.lessons.filter(o=>o.status==w.PRESENT).length,a=n.lessons.filter(o=>o.status==w.ABSENT).length;s.push({dailyLessonId:n.id,date:n.date,lastUpdate:n.lastSalaryUpdate,salary:n.salary,presents:t,absents:a})}),s}computeSalaryByStudentLesson(e,s){var t;if(!e)return 0;if(e.salaryStrategy==se.ABSENT_AND_PRESENT&&(s.status==w.PRESENT||s.status==w.ABSENT)||e.salaryStrategy==se.ONLY_PRESENT&&s.status==w.PRESENT){const a=(t=e.levelRanges.find(o=>o.levels.includes(s.level)))==null?void 0:t.price;if(a!=null)return a*((s.endTime-s.startTime)/60)}return 0}};g(F,"_instance",null);let X=F;const x=class x{static get instance(){return this._instance||(this._instance=new x),this._instance}async getDailyLessonOfSchoolByDate(e,s){const n=u(y("schoolId"),"==",e),t=u(y("date"),"==",s);return d.instance.getAll(n,t)}async getDailyLessonOfSchoolFromDate(e,s,n){const t=[],a=u(y("schoolId"),"==",e),o=u(y("date"),">=",s);return t.push(a,o),n&&t.push(te(y("date"),n)),d.instance.getAll(...t)}async getDailyLessonOfSchoolBetweenDate(e,s,n){const t=u(y("schoolId"),"==",e),a=u(y("date"),">=",s),o=u(y("date"),"<=",n);return await d.instance.getAll(t,a,o)}async getOrCreateDailyLessonId(e,s){return s instanceof Date?this.createDailyLessonByDate(e,s):this.handleLessonProjection(e,s)}async handleLessonProjection(e,s){if(!s.dailyLessonId){const n=this.buildDailyLessonFromProjection(e.schoolId,s);return d.instance.save(n)}return s.dailyLessonId}buildDailyLessonFromProjection(e,s){return{date:s.date.toIyyyyMMdd(),schoolId:e,lessons:s.lessons.map(n=>({lessonId:Q(),status:w.NONE,studentId:n.studentId,startTime:n.startTime,endTime:n.endTime,createdAt:S.now(),updatedAt:S.now()}))}}async createDailyLessonByDate(e,s){var o;const n=ae.fromDate(s).toIyyyyMMdd(),t=await x.instance.getDailyLessonOfSchoolByDate(e.schoolId,n);if((o=t==null?void 0:t[0])!=null&&o.id)return t[0].id;const a=this.buildDailyLessonFromWeeklyOrEmpty(e,s,n);return d.instance.save(a)}buildDailyLessonFromWeeklyOrEmpty(e,s,n){const t=e.weeklyLessons.find(a=>a.dayOfWeek===s.getDay());return t?{date:n,schoolId:e.schoolId,lessons:t.schedule.map(a=>({lessonId:Q(),status:w.NONE,studentId:a.studentId,startTime:a.startTime,endTime:a.endTime,createdAt:S.now(),updatedAt:S.now()}))}:{date:n,schoolId:e.schoolId,lessons:[]}}async removeRecoveryLesson(e){const s=await d.instance.getDoc(e.dailyLessonId);if(s.exists()){const n=s.data(),t=n.lessons.findIndex(a=>a.lessonId==e.lessonId);if(t!=-1){const a=n.lessons.splice(t,1)[0];a.recovery||console.warn("Deleting a lesson not marked as recovery lesson!",a),d.instance.save(n,n.id)}}}async createRecoveryLesson(e){const s={lessonId:Q(),status:w.NONE,studentId:e.studentId,startTime:e.startTime,endTime:e.endTime,recovery:{ref:"original",lessonRef:{dailyLessonId:e.originalDailyLessonId,lessonId:e.originalLessonId}},createdAt:S.now(),updatedAt:S.now()},n=await $.instance.getSchoolLessons(e.schoolId,e.date),t=await this.getOrCreateDailyLessonId(n,e.date),a=await d.instance.get(t);return a.lessons.push(s),await d.instance.save(a,a.id),{...s,dailyLessonId:a.id}}async removeRecoveryRef(e,s){const n=e.lessons.find(t=>t.lessonId==s);n&&n.recovery&&(delete n.recovery,await d.instance.save(e,e.id))}async moveRecoveryRefToUndoneList(e,s){const n=e.lessons.find(t=>t.lessonId==s);if(n&&n.recovery){const t={...n.recovery.lessonRef};n.undoneRecoveryRef||(n.undoneRecoveryRef=[]),n.undoneRecoveryRef.push(t),delete n.recovery,await d.instance.save(e,e.id)}}async addRecoveryRef(e,s,n){const t=e.lessons.find(a=>a.lessonId==s);t&&(t.recovery=n,await d.instance.save(e,e.id))}async deleteStudentLesson(e,s,n){const t=s.lessons.findIndex(a=>a.studentId==e.id)??-1;if(t==-1)return!1;try{const a=s.lessons[t];if(a.recovery){if(a.recovery.ref=="original"){const o=await d.instance.get(a.recovery.lessonRef.dailyLessonId),i=s;if(!o)return console.warn("Unable to cancel recovery because original daily lesson does not exist"),!1;const r={...e,originalDailyLesson:o,recoveryDailyLesson:i};await z.instance.cancelRecovery(r,n)}else if(a.recovery.ref=="recovery"){const o=await d.instance.get(a.recovery.lessonRef.dailyLessonId);if(!o)return console.warn("Unable to cancel recovery because recovery daily lesson does not exist"),!1;const r=(await U.instance.getStudentLesson(o)).find(l=>l.lessonId==a.recovery.lessonRef.lessonId);if(!r)return console.warn("Unable to cancel recovery because recovery student lesson does not exist"),!1;await this.deleteStudentLesson(r,o,!0),s.lessons.splice(t,1),await d.instance.save(s,s.id)}}return!0}catch{return!1}}async computeSalaryOfDailyLesson(e,s){const n=await d.instance.get(s);if(!n)return;const t=n.lessons.map(i=>i.studentId),a=await U.instance.getStudentLesson(n,t);let o=0;if(n.lessons.forEach(i=>{const r=a.find(l=>l.id==i.studentId);r!==void 0&&(o+=X.instance.computeSalaryByStudentLesson(e,r))}),o!=n.salary)return n.salary=o,n.lastSalaryUpdate=S.now(),await d.instance.save(n,n.id),n}};g(x,"_instance",null);let E=x;const j=class j{static get instance(){return this._instance||(this._instance=new j),this._instance}async getWeeklyLessonOfSchool(e){const s=u(y("schoolId"),"==",e);return B.instance.getAll(s)}async getWeeklyLessonOfSchoolByDayBetweenDate(e,s,n){const t=u(y("schoolId"),"==",e),a=u(y("dayOfWeek"),"==",s),o=u(y("from"),"<=",n),i=u(y("to"),">=",n);return B.instance.getAll(t,a,o,i)}observeWeekLessonOfSchool(e){const s=u(y("schoolId"),"==",e),n=te(y("dayOfWeek"));return B.instance.observeAll(s,n)}};g(j,"_instance",null);let Z=j;const V=class V{static get instance(){return this._instance||(this._instance=new V),this._instance}async deleteById(e){const s=G(ee()),n=await de.instance.getDoc(e);s.delete(n.ref),(await this.getSchoolRelations(e)).forEach(t=>s.delete(t)),await s.commit()}async delete(e){const s=G(ee()),n=e.id;s.delete(e),(await this.getSchoolRelations(n)).forEach(t=>s.delete(t)),await s.commit()}async getSchoolRelations(e){const s=[];return(await O.instance.getAllDocs(u(y("schoolId"),"==",e))).forEach(i=>s.push(i.ref)),(await B.instance.getAllDocs(u(y("schoolId"),"==",e))).forEach(i=>s.push(i.ref)),(await d.instance.getAllDocs(u(y("schoolId"),"==",e))).forEach(i=>s.push(i.ref)),(await R.instance.getAllDocs(u(y("schoolId"),"==",e))).forEach(i=>s.push(i.ref)),s}async getSchoolLessons(e,s){const n=s instanceof Date?ae.fromDate(s).toIyyyyMMdd():s,t=await E.instance.getDailyLessonOfSchoolFromDate(e,n,"desc"),a=await Z.instance.getWeeklyLessonOfSchool(e);return{dailyLessons:t,weeklyLessons:a,schoolId:e}}};g(V,"_instance",null);let $=V;export{E as D,ve as L,b as S,B as W,Z as a,$ as b,z as c,R as d,O as e,X as f,d as g,U as h,Q as v};
